par(mfrow = c(1, 2))
plot(ceb, net_m2, main = 'Алгоритм Edge-betweenness')
plot(cfg, net_m2, main = 'Алгоритм Fast Greedy')
net_m3 <- as.undirected(net_M3, mode = "collapse")
ceb <- cluster_edge_betweenness(net_m3, directed = F)
cfg <- cluster_fast_greedy(net_m3)
par(mfrow = c(1, 2))
plot(ceb, net_m3, main = 'Алгоритм Edge-betweenness')
plot(cfg, net_m3, main = 'Алгоритм Fast Greedy')
E(net_M)
V(net_M)
V(net_M)$Age
V(net_M)$Arrests
corr(V(net_M)$Age, V(net_M)$Arrests)
cor(V(net_M)$Age, V(net_M)$Arrests)
V(net_M)$arrests
V(net_M)$Arrests
cor(V(net_M)$Age, V(net_M)$Arrests)
cor(V(net_M)$Ranking, V(net_M)$Arrests)
cor(V(net_M)$Ranking, V(net_M)$Age)
?data.frame
?plot
all_features <- data.frame (V(net_M)$Age, V(net_M)$Birthplace, V(net_M)$Residence, V(net_M)$Arrests, V(net_M)$Convictions, V(net_M)$Music, V(net_M)$Ranking)
cor(all_features)
plot(net_m3)
V(net_m3)
V(net_m3)$Age
plot(net_m3, vertex.label = V(net_m3)$Age)
par(mfrow = c(1, 2))
par(mfrow = c(1, 1))
plot(net_m3, vertex.label = V(net_m3)$Age)
plot(net_m3, vertex.label = V(net_m3)$Ranking)
plot(net_m3, vertex.label = V(net_m3)$Ranking, vertex.size = 2)
plot(net_m3, vertex.label = V(net_m3)$Ranking, vertex.size = 4)
plot(net_m3, vertex.label = V(net_m3)$Ranking, vertex.size = 5)
plot(net_m3, vertex.label = V(net_m2)$Ranking, vertex.size = 5)
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 5)
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7)
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7)
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7, vertex.color = colr[V(net_m2$Ranking)])
colr = c("gray50", "gray50", "yellowgreen", "yellowgreen","gold")
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7, vertex.color = colr[V(net_m2$Ranking)])
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7, vertex.color = colr[V(net_m2$Ranking)])
# Ядро
net_m <- as.undirected(net_M, mode = "collapse")#убираем напраления
kc <- coreness(net_m) # subgraph in which every node has degree of at least k
kc
V(net_m2$Ranking)
V(net_m2)$Ranking)
> V(net_m2)$Ranking
V(net_m2)$Ranking
V(net_m2)$Ranking
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7, vertex.color = colr[V(net_m2)$Ranking])
colr = c("gold", "yellowgreen", "yellowgreen", "gray50", "gray50")
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7, vertex.color = colr[V(net_m2)$Ranking])
colr = c("gold", "yellowgreen", "yellowgreen", "gray80", "gray80")
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7, vertex.color = colr[V(net_m2)$Ranking])
colr = c("orange", "yellow", "green", "green", "gray80")
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7, vertex.color = colr[V(net_m2)$Ranking])
colr = c("orange", "yellow", "yellowgreen", "darkgreen", "gray80")
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7, vertex.color = colr[V(net_m2)$Ranking])
colr = c("orange", "yellow", "yellowgreen", "lightgreen", "gray80")
plot(net_m2, vertex.label = V(net_m2)$Ranking, vertex.size = 7, vertex.color = colr[V(net_m2)$Ranking])
plot(net_m3, vertex.label = V(net_m3)$Age)
plot(net_m3, vertex.label = V(net_m3)$Birthplace)
plot(net_m2, vertex.label = V(net_m3)$Birthplace)
plot(net_m2, vertex.label = V(net_m2)$Birthplace)
plot(net_m2, vertex.label = V(net_m2)$Birthplace, vertex.size = 7)
ceb <- cluster_edge_betweenness(net_m2, directed = F, vertex.label = V(net_m2)$Arrests)
ceb <- cluster_edge_betweenness(net_m2, directed = F, vertex.label = V(net_m2)$Arrests)
V(net_m2)$Arrests
A <- as_adjacency_matrix(net_M, names = TRUE)
A
A <- as.matrix(A)
Neighbors <- rowSums(A)
Neighbors
type(Neighbors)
typeof(Neighbors)
library(statnet) # не пакет igraph
install.packages("statnet")
install.packages("ergm")
?ergmTerm# ergmTerm в Help: список возможных характеристик графов
library(statnet) # не пакет igraph
library(ergm)
set.seed(0)
?ergmTerm# ergmTerm в Help: список возможных характеристик графов
# выберем знакомый набор данных из встроенных
data(florentine)
flomarriage # рассмотрим только брачную сеть
library(intergraph) # пакет, чтобы в стандартный igraph превратить
network_M <- as.network(net_m)
network_M <- as.network(net_M)
?as.network
summary(net_M)
as.network(net_M)
as.network(net_M, matrix.type = 'adjacency')
as.network(net_M, matrix.type = 'adjacency', directed  = False, vertex_attr = c(V(net_M)$Age, V(net_M)$Birthplace, V(net_M)$Residence, V(net_M)$Arrests, V(net_M)$Convictions, V(net_M)$Music, V(net_M)$Ranking))
network_M <- as.network(M)
network_M
vertex.names
V(network_M)
network_M <- asNetwork(M, directed = F, )
library(intergraph) # пакет, чтобы в стандартный igraph превратить
ergm_model <- asNetwork(net_M)
ergm_model
# simple Erdos-Renyi model, нулевая модель, только число ребер -- характеристика графа
summary(ergm_model ~ edges) # посмотрим, сколько вообще ребер
(ergm_model.01 <- ergm(ergm_model ~ edges) # Estimate the model
ergm_model.01
ergm_model.01 <- ergm(ergm_model ~ edges) # Estimate the model
ergm_model.01 <- ergm(ergm_model ~ edges) # Estimate the model
ergm_model.01
summary(flomodel.01)
# в формуле у -- это название сети
summary(ergm_model.01) # поглядим интерпретацию в презентации лекции
?nodecov
ergm_mode
ergm_model
ergm_model('age')
V(ergm_model)
ergm_model <- asNetwork(net_M)
?ergm
ergm_model
# добавляем характеристику вершине
ergm_model.02 <- ergm(ergm_model ~ edges + nodecov('Arrests'))
# более богатые вершины более вероятно устанавливают ребра-связи
# nodefactor для категориальных переменных
# nodematch для совпадения типов вершин (ассортативность), nodemix
summary(ergm_model.02) # поглядим интерпретацию в презентации
ergm_model.03 <- ergm(ergm_model ~ edges + nodecov('Arrests') + nodecov('Age') + nodecov('Birthplace') nodecov('Convictions') + nodecov('Music') + nodecov('Prison') + nodecov('Ranking') + nodecov('Residence') + triangles)
e
ergm_model.03 <- ergm(ergm_model ~ edges + nodecov('Arrests') + nodecov('Age') + nodecov('Birthplace') + nodecov('Convictions') + nodecov('Music') + nodecov('Prison') + nodecov('Ranking') + nodecov('Residence') + triangles)
# data import
nodes <- read.csv("C:/Users/Serge/OneDrive - экономический факультет МГУ им. М.В.Ломоносова/МГУ/5 семестр/Сетевые модели/ДЗ/LONDON_GANG_ATTR.csv", header=T)
M <- read.csv("C:/Users/Serge/OneDrive - экономический факультет МГУ им. М.В.Ломоносова/МГУ/5 семестр/Сетевые модели/ДЗ/LONDON_GANG.csv", header=T)[2:55]
M <- as.matrix(M)
# creating graph with edge weights, direction and vertex features
net_M <- graph_from_adjacency_matrix(M, mode = "directed", weighted = TRUE)
nodes$X <- paste("X", nodes$X, sep = "")
net_M <- set_vertex_attr(net_M, "Age", nodes$X, nodes$Age)
net_M <- set_vertex_attr(net_M, "Birthplace", nodes$X, nodes$Birthplace)
net_M <- set_vertex_attr(net_M, "Residence", nodes$X, nodes$Residence)
net_M <- set_vertex_attr(net_M, "Arrests", nodes$X, nodes$Arrests)
net_M <- set_vertex_attr(net_M, "Convictions", nodes$X, nodes$Convictions)
net_M <- set_vertex_attr(net_M, "Convictions", nodes$X, nodes$Prison)
net_M <- set_vertex_attr(net_M, "Music", nodes$X, nodes$Music)
net_M <- set_vertex_attr(net_M, "Ranking", nodes$X, nodes$Ranking)
all_features <- data.frame (V(net_M)$Age, V(net_M)$Birthplace, V(net_M)$Residence, V(net_M)$Arrests, V(net_M)$Convictions, V(net_M)$Music, V(net_M)$Ranking)
cor(all_features)
ergm_model <- asNetwork(net_M)
library(intergraph) # пакет, чтобы в стандартный igraph превратить
ergm_model <- asNetwork(net_M)
library(statnet) # не пакет igraph
library(ergm)
set.seed(0)
?ergmTerm# ergmTerm в Help: список возможных характеристик графов
ergm_model.03 <- ergm(ergm_model ~ edges + nodecov('Birthplace') + nodecov('Convictions') + nodecov('Residence') + triangles)
1+1
ergm_model.03 <- ergm(ergm_model ~ triangles)
mcmc.diagnostics()
mcmc.diagnostics(flomodel.03)
mcmc.diagnostics(ergm_model.03)
summary(ergm_model.03)
summary(ergm_model.03)
ergm_model.03 <- ergm(ergm_model ~ triangles + edges)
ergm_model.03 <- ergm(ergm_model ~ edges + nodecov('Arrests') + nodecov('Age') + nodecov('Birthplace') + nodecov('Convictions') + nodecov('Prison') + nodecov('Residence'))
summary(ergm_model.03)
?gof
# One test of whether a local model “fits the data” is therefore how well it reproduces
# the observed global network properties that are not in the model
# comparing the value of this statistic observed in the original network
# to the distribution of values we get in simulated networks from our model
ergm_model.03.gof <- gof(ergm_model.03)
ergm_model.03.gof # esp(i) -- сколько у пары вершин общих соседей
ergm_model.03 <- ergm(ergm_model ~ triangles)
ergm_model.03 <- ergm(ergm_model ~ edges + nodecov('Arrests') + nodecov('Age') + nodecov('Birthplace') + nodecov('Convictions') + nodecov('Prison') + nodecov('Residence') + nodecov('Music'))
summary(ergm_model.03)
net_M
V(net_M)
V(net_M)$Prison
# data import
nodes <- read.csv("C:/Users/Serge/OneDrive - экономический факультет МГУ им. М.В.Ломоносова/МГУ/5 семестр/Сетевые модели/ДЗ/LONDON_GANG_ATTR.csv", header=T)
M <- read.csv("C:/Users/Serge/OneDrive - экономический факультет МГУ им. М.В.Ломоносова/МГУ/5 семестр/Сетевые модели/ДЗ/LONDON_GANG.csv", header=T)[2:55]
M <- as.matrix(M)
# creating graph with edge weights, direction and vertex features
net_M <- graph_from_adjacency_matrix(M, mode = "directed", weighted = TRUE)
nodes$X <- paste("X", nodes$X, sep = "")
net_M <- set_vertex_attr(net_M, "Age", nodes$X, nodes$Age)
net_M <- set_vertex_attr(net_M, "Birthplace", nodes$X, nodes$Birthplace)
net_M <- set_vertex_attr(net_M, "Residence", nodes$X, nodes$Residence)
net_M <- set_vertex_attr(net_M, "Arrests", nodes$X, nodes$Arrests)
net_M <- set_vertex_attr(net_M, "Convictions", nodes$X, nodes$Convictions)
net_M <- set_vertex_attr(net_M, "Convictions", nodes$X, nodes$Prison)
net_M <- set_vertex_attr(net_M, "Music", nodes$X, nodes$Music)
net_M <- set_vertex_attr(net_M, "Ranking", nodes$X, nodes$Ranking)
net_M
# creating graph with edge weights, direction and vertex features
net_M <- graph_from_adjacency_matrix(M, mode = "directed", weighted = TRUE)
nodes$X <- paste("X", nodes$X, sep = "")
net_M <- set_vertex_attr(net_M, "Age", nodes$X, nodes$Age)
net_M <- set_vertex_attr(net_M, "Birthplace", nodes$X, nodes$Birthplace)
net_M <- set_vertex_attr(net_M, "Residence", nodes$X, nodes$Residence)
net_M <- set_vertex_attr(net_M, "Arrests", nodes$X, nodes$Arrests)
net_M <- set_vertex_attr(net_M, "Convictions", nodes$X, nodes$Convictions)
net_M <- set_vertex_attr(net_M, "Prison", nodes$X, nodes$Prison)
net_M <- set_vertex_attr(net_M, "Music", nodes$X, nodes$Music)
net_M <- set_vertex_attr(net_M, "Ranking", nodes$X, nodes$Ranking)
#install.packages("igraph")
#install.packages("igraphdata")
library(igraph)
library(igraphdata)
library(ggplot2)
# data import
nodes <- read.csv("C:/Users/Serge/OneDrive - экономический факультет МГУ им. М.В.Ломоносова/МГУ/5 семестр/Сетевые модели/ДЗ/LONDON_GANG_ATTR.csv", header=T)
M <- read.csv("C:/Users/Serge/OneDrive - экономический факультет МГУ им. М.В.Ломоносова/МГУ/5 семестр/Сетевые модели/ДЗ/LONDON_GANG.csv", header=T)[2:55]
M <- as.matrix(M)
# creating graph with edge weights, direction and vertex features
net_M <- graph_from_adjacency_matrix(M, mode = "directed", weighted = TRUE)
nodes$X <- paste("X", nodes$X, sep = "")
net_M <- set_vertex_attr(net_M, "Age", nodes$X, nodes$Age)
net_M <- set_vertex_attr(net_M, "Birthplace", nodes$X, nodes$Birthplace)
net_M <- set_vertex_attr(net_M, "Residence", nodes$X, nodes$Residence)
net_M <- set_vertex_attr(net_M, "Arrests", nodes$X, nodes$Arrests)
net_M <- set_vertex_attr(net_M, "Convictions", nodes$X, nodes$Convictions)
net_M <- set_vertex_attr(net_M, "Prison", nodes$X, nodes$Prison)
net_M <- set_vertex_attr(net_M, "Music", nodes$X, nodes$Music)
net_M <- set_vertex_attr(net_M, "Ranking", nodes$X, nodes$Ranking)
V(net_M)$Prison
V(net_M)$Convictions
net_M
nodes$Ranking
nodes$Birthplace
nodes$Birthplace == 1
(nodes$Birthplace == 1) * 1
net_M <- set_vertex_attr(net_M, "West Africa", nodes$X, (nodes$Birthplace == 1) * 1)
net_M <- set_vertex_attr(net_M, "Caribbean", nodes$X, (nodes$Birthplace == 2) * 1)
net_M <- set_vertex_attr(net_M, "East Africa", nodes$X, (nodes$Birthplace == 4) * 1)
net_M
V(net_M)
V(net_M)$West Africa
# creating graph with edge weights, direction and vertex features
net_M <- graph_from_adjacency_matrix(M, mode = "directed", weighted = TRUE)
nodes$X <- paste("X", nodes$X, sep = "")
net_M <- set_vertex_attr(net_M, "Age", nodes$X, nodes$Age)
net_M <- set_vertex_attr(net_M, "Birthplace", nodes$X, nodes$Birthplace)
net_M <- set_vertex_attr(net_M, "Residence", nodes$X, nodes$Residence)
net_M <- set_vertex_attr(net_M, "Arrests", nodes$X, nodes$Arrests)
net_M <- set_vertex_attr(net_M, "Convictions", nodes$X, nodes$Convictions)
net_M <- set_vertex_attr(net_M, "Prison", nodes$X, nodes$Prison)
net_M <- set_vertex_attr(net_M, "Music", nodes$X, nodes$Music)
net_M <- set_vertex_attr(net_M, "Ranking", nodes$X, nodes$Ranking)
library(statnet)
library(ergm)
set.seed(0)
library(intergraph) # пакет, чтобы в стандартный igraph превратить
net_M <- set_vertex_attr(net_M, "West_Africa", nodes$X, (nodes$Birthplace == 1) * 1)
net_M <- set_vertex_attr(net_M, "Caribbean", nodes$X, (nodes$Birthplace == 2) * 1)
net_M <- set_vertex_attr(net_M, "East_Africa", nodes$X, (nodes$Birthplace == 4) * 1)
# data import
nodes <- read.csv("C:/Users/Serge/OneDrive - экономический факультет МГУ им. М.В.Ломоносова/МГУ/5 семестр/Сетевые модели/ДЗ/LONDON_GANG_ATTR.csv", header=T)
M <- read.csv("C:/Users/Serge/OneDrive - экономический факультет МГУ им. М.В.Ломоносова/МГУ/5 семестр/Сетевые модели/ДЗ/LONDON_GANG.csv", header=T)[2:55]
M <- as.matrix(M)
# creating graph with edge weights, direction and vertex features
net_M <- graph_from_adjacency_matrix(M, mode = "directed", weighted = TRUE)
nodes$X <- paste("X", nodes$X, sep = "")
net_M <- set_vertex_attr(net_M, "Age", nodes$X, nodes$Age)
net_M <- set_vertex_attr(net_M, "Birthplace", nodes$X, nodes$Birthplace)
net_M <- set_vertex_attr(net_M, "Residence", nodes$X, nodes$Residence)
net_M <- set_vertex_attr(net_M, "Arrests", nodes$X, nodes$Arrests)
net_M <- set_vertex_attr(net_M, "Convictions", nodes$X, nodes$Convictions)
net_M <- set_vertex_attr(net_M, "Prison", nodes$X, nodes$Prison)
net_M <- set_vertex_attr(net_M, "Music", nodes$X, nodes$Music)
net_M <- set_vertex_attr(net_M, "Ranking", nodes$X, nodes$Ranking)
net_M <- set_vertex_attr(net_M, "West_Africa", nodes$X, (nodes$Birthplace == 1) * 1)
net_M <- set_vertex_attr(net_M, "Caribbean", nodes$X, (nodes$Birthplace == 2) * 1)
net_M <- set_vertex_attr(net_M, "East_Africa", nodes$X, (nodes$Birthplace == 4) * 1)
V(net_M)$West_Africa
ergm_model <- asNetwork(net_M)
net_M
V(net_M)$Birthplace
V(net_M)$Residents
V(net_M)$Resident
net_M
V(net_M)$Residence
ergm_model.03 <- ergm(ergm_model ~ edges + nodecov('Arrests') + nodecov('Age') + nodecov('Convictions') + nodecov('Prison') + nodecov('West_Africa') + nodecov('Caribbean') +  nodecov('East_Africa') + nodecov('Residence'))
summary(ergm_model.03)
V(net_M)$Arests
net_M
V(net_M)$Arrests
V(net_M)$Convictions\
V(net_M)$Convictions
ergm_model.01 <- ergm(ergm_model ~ edges + nodecov('Arrests') + nodecov('Age') + nodecov('Convictions') + nodecov('West_Africa') + nodecov('Caribbean') +  nodecov('East_Africa') + nodecov('Residence'))
summary(ergm_model.01)
ergm_model.02 <- ergm(ergm_model ~ triangles + nodecov('Arrests'))
# можно насимулировать графов по нашей модели
ergm_model.01.sim <- simulate(ergm_model.01, nsim=10)
ergm_model.01.sim[[1]] # это граф, можно его любые характеристики взять и сравнить с наблюдаемым графом
ergm_model.01.sim$Vertex
ergm_model.01.sim$Age
?egrm
?ergm
net_M2 =delete.edges(net_M, which(E(net_M)$weight <=1))
ergm_model2 <- asNetwork(net_M2)
ergm_model.015 <- ergm(ergm_model2 ~ edges + nodecov('Arrests') + nodecov('Age') + nodecov('Convictions') + nodecov('Prison') + nodecov('West_Africa') + nodecov('Caribbean') +  nodecov('East_Africa') + nodecov('Residence'))
summary(ergm_model.015)
mcmc.diagnostics(ergm_model.015)
ergm_model.015 <- ergm(ergm_model2 ~ edges + nodecov('Arrests') + nodecov('Age') + nodecov('Convictions') + nodecov('Prison') + nodecov('West_Africa') + nodecov('Caribbean') +  nodecov('East_Africa') + nodecov('Residence'))
summary(ergm_model.015)
mcmc.diagnostics(ergm_model.015)
ergm_model.02 <- ergm(ergm_model ~ triangles)
mcmc.diagnostics(ergm_model.02)
mcmc.diagnostics(ergm_model.02)
ergm_model.02.gof <- gof(ergm_model.02)
ergm_model.02.gof # esp(i) -- сколько у пары вершин общих соседей
ergm_model.02.gof <- gof(ergm_model.015)
ergm_model.02.gof # esp(i) -- сколько у пары вершин общих соседей
# с помощью аргумента GOF можно выбрать сравниваемые характеристики
plot(ergm_model.02.gof) # тоже самое графически по всем сравниваемым характеристикам
ergm_model.01 <- ergm(ergm_model ~ edges + nodecov('Arrests') + nodecov('Age') + nodecov('Convictions') + nodecov('Prison') + nodecov('West_Africa') + nodecov('Caribbean') +  nodecov('East_Africa') + nodecov('Residence'))
summary(ergm_model.01)
ergm_model.01.gof <- gof(ergm_model.01)
ergm_model.01.gof
plot(ergm_model.01.gof)
par(mfrow = c(1, 1))
plot(ergm_model.01.gof)
plot(ergm_model.01.gof, main = 'Модель 1')
plot(ergm_model.01.gof, main = 'Goodness-of-fit для модели №1')
ergm_model.015.gof <- gof(ergm_model.015)
ergm_model.015.gof
plot(ergm_model.015.gof, main = 'Goodness-of-fit для модели №1')
plot(ergm_model.015.gof, main = 'Goodness-of-fit для модели №2')
LS -A
ls -a
ls
cd
library(mvtnorm)
library('forecast')
library(xtable)
library(plotrix)
rm(list = ls())
set.seed(1234)
#setwd('/Users/darkhangelsky/Library/CloudStorage/Dropbox-Personal/Research/aggregate_iv/code/simulation_paper/Nakamura')
source('implementation/synth_weights.r')
W_mat_or <- data_nak[[2]][-1,]
#setwd('/Users/darkhangelsky/Library/CloudStorage/Dropbox-Personal/Research/aggregate_iv/code/simulation_paper/Nakamura')
source('implementation/synth_weights.r')
devtools::install_github("synth-inference/synthdid")
intall.packages('devtools')
install.packages('devtools')
devtools::install_github("synth-inference/synthdid")
library(synthdid)
# Estimate the effect of California Proposition 99 on cigarette consumption
data('california_prop99')
?panel.matrices
california_prop99
tau.hat = synthdid_estimate(setup$Y, setup$N0, setup$T0)
setup = panel.matrices(california_prop99)
tau.hat = synthdid_estimate(setup$Y, setup$N0, setup$T0)
tau.hat
summary.synthdid_estimate(tau.hat)
?summary.synthdid_estimate
?synthdid_plot
synthdid_plot(tau.hat)
devtools::install_github("AntonZudin/Robust-TSLS-package")
devtools::install_github("AntonZudin/Robust-TSLS-package")
library(RobustTSLS)
data('nak_out_data')
Y_mat_or <- data_nak[[1]][-1,]
W_mat_or <- data_nak[[2]][-1,]
Z <- data_nak[[3]]
start_year <- 1968
state_names <- data_nak[[4]][-1]
T <- dim(W_mat_or)[2]
T_0 <- 10
pi_unit <- W_mat_or%*%(Z-mean(Z)) / var_biased(Z)/T #calculate D_i
index_sub <- pi_unit >= quantile(pi_unit, 0.04) & pi_unit <= quantile(pi_unit, 1)#drop inappropriate states
robust_estimates <- robust_estimate(Y_mat_or, W_mat_or, Z, index_sub, T_0,
state_names, time_column = TRUE)
robust_estimates
print.robust_estimate(robust_estimates)
robust_estimates$index_sub
robust_estimate()
robust_estimates
attributes(robust_estimates)
plot_2(robust_estimates, T_0, 1968)
plot_2(robust_estimates, T_0, 1968)
setwd("C:/Users/Serge/OneDrive - экономический факультет МГУ им. М.В.Ломоносова/Митя/Robust-TSLS-package")
remove.packages('RobustTSLS')
devtools::install_github("AntonZudin/Robust-TSLS-package")
devtools::install_github("AntonZudin/Robust-TSLS-package")
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
library(RobustTSLS)
data('nak_out_data')
Y_mat_or <- data_nak[[1]][-1,]
W_mat_or <- data_nak[[2]][-1,]
Z <- data_nak[[3]]
start_year <- 1968
state_names <- data_nak[[4]][-1]
T <- dim(W_mat_or)[2]
T_0 <- 10
pi_unit <- W_mat_or%*%(Z-mean(Z)) / var_biased(Z)/T #calculate D_i
index_sub <- pi_unit >= quantile(pi_unit, 0.04) & pi_unit <= quantile(pi_unit, 1)#drop inappropriate states
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
remove.packages('RobustTSLS')
devtools::install_github("AntonZudin/Robust-TSLS-package")
library(RobustTSLS)
data('nak_out_data')
Y_mat_or <- data_nak[[1]][-1,]
W_mat_or <- data_nak[[2]][-1,]
Z <- data_nak[[3]]
start_year <- 1968
state_names <- data_nak[[4]][-1]
T <- dim(W_mat_or)[2]
T_0 <- 10
pi_unit <- W_mat_or%*%(Z-mean(Z)) / var_biased(Z)/T #calculate D_i
index_sub <- pi_unit >= quantile(pi_unit, 0.04) & pi_unit <= quantile(pi_unit, 1)#drop inappropriate states
robust_estimates <- robust_estimate(Y_mat_or, W_mat_or, Z, index_sub, T_0,
state_names, time_column = TRUE)
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
remove.packages('RobustTSLS')
devtools::install_github("AntonZudin/Robust-TSLS-package")
devtools::install_github("AntonZudin/Robust-TSLS-package")
devtools::install_github("AntonZudin/Robust-TSLS-package")
library(RobustTSLS)
data('nak_out_data')
Y_mat_or <- data_nak[[1]][-1,]
W_mat_or <- data_nak[[2]][-1,]
Z <- data_nak[[3]]
start_year <- 1968
state_names <- data_nak[[4]][-1]
T <- dim(W_mat_or)[2]
robust_estimates <- robust_estimate(Y_mat_or, W_mat_or, Z, index_sub, T_0,
state_names, time_column = TRUE)
Y_mat_or
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
devtools::install_github("AntonZudin/Robust-TSLS-package")
library(RobustTSLS)
data('nak_out_data')
Y_mat_or <- data_nak[[1]][-1,]
W_mat_or <- data_nak[[2]][-1,]
Z <- data_nak[[3]]
start_year <- 1968
state_names <- data_nak[[4]][-1]
T <- dim(W_mat_or)[2]
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
pi_unit <- W_mat_or%*%(Z-mean(Z)) / var_biased(Z)/T #calculate D_i
index_sub <- pi_unit >= quantile(pi_unit, 0.04) & pi_unit <= quantile(pi_unit, 1)#drop inappropriate states
robust_estimates <- robust_estimate(Y_mat_or, W_mat_or, Z, index_sub, T_0,
state_names, time_column = TRUE)
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
remove.packsage('RobustTSLS')
remove.packsages('RobustTSLS')
remove.packages('RobustTSLS')
devtools::install_github("AntonZudin/Robust-TSLS-package")
library(RobustTSLS)
data('nak_out_data')
Y_mat_or <- data_nak[[1]][-1,]
W_mat_or <- data_nak[[2]][-1,]
Z <- data_nak[[3]]
start_year <- 1968
state_names <- data_nak[[4]][-1]
T <- dim(W_mat_or)[2]
T_0 <- 10
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
remove.packages('RobustTSLS')
devtools::install_github("AntonZudin/Robust-TSLS-package")
library(RobustTSLS)
data('nak_out_data')
Y_mat_or <- data_nak[[1]][-1,]
W_mat_or <- data_nak[[2]][-1,]
Z <- data_nak[[3]]
start_year <- 1968
state_names <- data_nak[[4]][-1]
T <- dim(W_mat_or)[2]
T_0 <- 10
pi_unit <- W_mat_or%*%(Z-mean(Z)) / var_biased(Z)/T #calculate D_i
index_sub <- pi_unit >= quantile(pi_unit, 0.04) & pi_unit <= quantile(pi_unit, 1)#drop inappropriate states
robust_estimates <- robust_estimate(Y_mat_or, W_mat_or, Z, index_sub, T_0,
state_names, time_column = TRUE)
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, NULL, 1234)
remove.packages('RobustTSLS')
devtools::install_github("AntonZudin/Robust-TSLS-package")
library(RobustTSLS)
data('nak_out_data')
Y_mat_or <- data_nak[[1]][-1,]
W_mat_or <- data_nak[[2]][-1,]
Z <- data_nak[[3]]
start_year <- 1968
state_names <- data_nak[[4]][-1]
T <- dim(W_mat_or)[2]
T_0 <- 10
pi_unit <- W_mat_or%*%(Z-mean(Z)) / var_biased(Z)/T #calculate D_i
index_sub <- pi_unit >= quantile(pi_unit, 0.04) & pi_unit <= quantile(pi_unit, 1)#drop inappropriate states
robust_estimates <- robust_estimate(Y_mat_or, W_mat_or, Z, index_sub, T_0,
state_names, time_column = TRUE)
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, 16*0.75, 9*0.75, NULL, 1234)
remove.packages('RobustTSLS')
devtools::install_github("AntonZudin/Robust-TSLS-package")
library(RobustTSLS)
data('nak_out_data')
Y_mat_or <- data_nak[[1]][-1,]
W_mat_or <- data_nak[[2]][-1,]
Z <- data_nak[[3]]
start_year <- 1968
state_names <- data_nak[[4]][-1]
T <- dim(W_mat_or)[2]
T_0 <- 10
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, 16*0.75, 9*0.75, NULL, 1234)
simulation(Y_mat_or, W_mat_or, Z, 1/3, 1/3, 0.5, 0.2, 0.3, 1000, 300, FALSE, 300, 4, 16*0.75, 9*0.75, NULL, 1234)
